# Отчет
0. Запуск из matrix: **make (IMPR="-g -O3"); ./main; make clear**
1. Реализовать классическое перемножение матриц и умножение матрицы на вектор на C/C++ с разным порядком циклов - сделано (matrix.hpp, matrix.cpp, Makefile в **matrix**).
2. Разбейте на модули, со статической линковкой скомпилируйте текст, подготовьте Makefile, проверьте флаги -g,  -O3 - сделано, можно проверить с помощью переменной IMPR. Странно, но на этой реализации с применением стандартов C++-11 не удалось добиться прироста производительности выставлением этих флагов (**IMPORTANT**: тесты проводились на архитектуре arm64 (M1 процессор), возможно, в этом причина, точно не знаю):
    2.1. make
        2.1.1. ijk time (512): 690 ms
        2.1.2. jik time (512): 699 ms
        2.1.3. jik time (512): 639 ms
    2.2. make -g
        2.2.1. ijk time (512): 722 ms
        2.2.2. jik time (512): 715 ms
        2.2.3. jik time (512): 642 ms
    2.3. make -O3
        2.3.1. ijk time (512): 710 ms
        2.3.2. jik time (512): 706 ms
        2.3.3. jik time (512): 643 ms
3. Измерьте времена исполнения для размеров $N = 500, 512, 1000, 1024, 2000, 2048$ - проведены сравнения только для kij-перемножения:
    3.1. 500: 594 ms
    3.2. 512: 639 ms
    3.3. 1000: 4803 ms
    3.4. 1024: 5131 ms
    3.5. 2000: 39353 ms
    3.6. 2048: 42409 ms
    3.7. Интересно, что конкретно в моем случае гипотеза о более быстром перемножении матриц с размером степени 2 не подтвердилась. Использовал g++ -std=c++0x, как можно увидеть в Makefile.
4. bash скрипт с реализацией заданий находится в папке bash
